var tipuesearch = {"pages": [{'title': 'First', 'text': 'About \n \n  https://github.com/mdecycu/cmsite \n', 'tags': '', 'url': 'First.html'}, {'title': 'W5', 'text': '// 包含標準輸出入程式庫的標頭文件\n// https://blog.csdn.net/weixin_38468077/article/details/101069365\n// http://www.gnuplot.info/demo/\n// https://github.com/sysprog21/rv32emu\n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3\n// https://cs61c.org/fa23/\n// https://greenteapress.com/wp/think-python-2e/\n// https://github.com/ecalvadi/c99-examples\n// https://github.com/gouravthakur39/beginners-C-program-examples\n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples\n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf\n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf\n// https://jsommers.github.io/cbook/cbook.pdf\n// https://jsommers.github.io/cbook/index.html\n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf\n// http://cslibrary.stanford.edu/101/EssentialC.pdf\n// https://publications.gbdirect.co.uk/c_book/\n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf\n// ***** execute on replit \n// cd downloads\n// cc gnuplot_ex1.c -o gnuplot_ex1\n// ./gnuplot_ex1\n#include <stdio.h>\n  \n// 主函式\nint main() {\n    // Start a Gnuplot process using popen\n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");\n    if (!gnuplotPipe) {\n        fprintf(stderr, "Failed to start Gnuplot.\\n");\n        return 1;\n    }\n  \n    // Use Gnuplot plotting commands, specify font and output as PNG\n    fprintf(gnuplotPipe, "set terminal png font \'default,10\' size 800,400\\n");\n    fprintf(gnuplotPipe, "set output \'./../images/gnuplot_ex1.png\'\\n");\n    fprintf(gnuplotPipe, "plot sin(x)");\n    // Close popen\n    pclose(gnuplotPipe);\n  \n    return 0;\n} \n \n \n \n \n', 'tags': '', 'url': 'W5.html'}, {'title': 'W6', 'text': '', 'tags': '', 'url': 'W6.html'}, {'title': '中華民國國旗程式', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue);\n\nint main() {\n// width 3: height 2\nint width = 1200;\nint height = (int)(width*2.0 / 3.0);\n\ngdImagePtr img = gdImageCreateTrueColor(width, height);\ngdImageAlphaBlending(img, 0);\n\ndraw_roc_flag(img);\n\nFILE *outputFile = fopen("./roc_flag.png", "wb");\nif (outputFile == NULL) {\nfprintf(stderr, "Error opening the output file.\\n");\nreturn 1;\n}\ngdImagePngEx(img, outputFile, 9);\nfclose(outputFile);\ngdImageDestroy(img);\nreturn 0;\n}\n\nvoid draw_roc_flag(gdImagePtr img) {\nint width = gdImageSX(img);\nint height = gdImageSY(img);\nint red, white, blue;\nint center_x = (int)(width/4);\nint center_y = (int)(height/4);\nint sun_radius = (int)(width/8);\n\n// Colors for the flag\nred = gdImageColorAllocate(img, 242, 0, 0); // Red color\nwhite = gdImageColorAllocate(img, 255, 255, 255); // White stripes\nblue = gdImageColorAllocate(img, 0, 41, 204); // Blue\n\n// 繪製紅色矩形區域\ngdImageFilledRectangle(img, 0, 0, width, height, red);\n\n// 繪製藍色矩形區域\ngdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n\n// 繪製太陽\ndraw_white_sun(img, center_x, center_y, sun_radius, white, red, blue);\n}\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue) {\nfloat angle = 0;\nint numRays = 12; // 光芒的數量\n\ngdPoint points[3]; // 三個頂點的陣列\n\nfor (int i = 0; i < numRays; i++) {\nangle = i * (2 * M_PI / numRays);\nfloat x1 = center_x + cos(angle) * sun_radius;\nfloat y1 = center_y + sin(angle) * sun_radius;\n\n// 調整兩個底邊頂點的位置\nfloat x2 = center_x + cos(angle + 0.35) * (sun_radius * 0.5);\nfloat y2 = center_y + sin(angle + 0.35) * (sun_radius * 0.5);\nfloat x3 = center_x + cos(angle - 0.35) * (sun_radius * 0.5);\nfloat y3 = center_y + sin(angle - 0.35) * (sun_radius * 0.5);\n\n// 設定多邊形的三個頂點\npoints[0].x = (int)x1;\npoints[0].y = (int)y1;\npoints[1].x = (int)x2;\npoints[1].y = (int)y2;\npoints[2].x = (int)x3;\npoints[2].y = (int)y3;\n\ngdImageFilledPolygon(img, points, 3, white);\n}\n//外圈\ngdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.2, sun_radius * 1.2, blue);\n\n// 繪製太陽內部\ngdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.1, sun_radius * 1.1, white);\n} \n \n \n', 'tags': '', 'url': '中華民國國旗程式.html'}, {'title': '美國國旗程式', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_usa_flag(gdImagePtr img);\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n\nint main() {\nint width = 800;\nint height = (int)(width / 1.9);\n\ngdImagePtr img = gdImageCreateTrueColor(width, height);\ngdImageAlphaBlending(img, 0);\n\ndraw_usa_flag(img);\n\nFILE *outputFile = fopen("./../images/usa_flag.png", "wb");\nif (outputFile == NULL) {\nfprintf(stderr, "打开输出文件时出错。\\n");\nreturn 1;\n}\n\ngdImagePngEx(img, outputFile, 9);\nfclose(outputFile);\ngdImageDestroy(img);\n\nreturn 0;\n}\n\nvoid draw_usa_flag(gdImagePtr img) {\nint width = gdImageSX(img);\nint height = gdImageSY(img);\nint red, white, blue;\n// 国旗颜色\nred = gdImageColorAllocate(img, 178, 34, 52); // 红色条纹\nwhite = gdImageColorAllocate(img, 255, 255, 255); // 白色条纹\nblue = gdImageColorAllocate(img, 60, 59, 110); // 蓝色矩形\n\nint stripe_height = height / 13;\nint stripe_width = width;\nint star_size = (int)(0.0308 * height); // 星星大小\n\nfor (int y = 0; y < height; y += stripe_height) {\nif (y / stripe_height % 2 == 0) {\ngdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, red);\n} else {\ngdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, white);\n}\n}\n\ngdImageFilledRectangle(img, 0, 0, width * 2 / 5, stripe_height * 7, blue);\n\nint star_spacing_x = (int)(0.129 * height); // 横向星星之间的间距\nint star_spacing_y = (int)(0.054 * height); // 纵向星星之间的间距\nint star_start_x = (int)(0.125 * height); // 星星的起始X位置\nint star_start_y = (int)(0.0485 * height); // 星星的起始Y位置\n\nfor (int row = 0; row < 9; row++) {\nint starsPerRow = (row % 2 == 0) ? 6 : 5;\n\n// 计算2、4、6和8排星星的偏移量\nint offset_x = (row % 2 == 0) ? star_spacing_x / -2 : 0;\n\nfor (int star = 0; star < starsPerRow; star++) {\nint x = star_start_x + star * star_spacing_x + offset_x;\n\n// 旋转角度（以弧度为单位）\ndouble rotation_angle = M_PI / 5; // 忘記多少度的旋转\n\nint y = star_start_y + row * star_spacing_y;\ndraw_star(img, x, y, star_size, white, rotation_angle);\n}\n}\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\ngdPoint points[10];\n\nfor (int i = 0; i < 10; i++) {\ndouble angle = M_PI / 2 + i * 2 * M_PI / 10 + rotation_angle;\nint radius = (i % 2 == 0) ? size : size / 2;\npoints[i].x = x + radius * cos(angle);\npoints[i].y = y + radius * sin(angle);\n}\n\n// 用指定的颜色填充星星\ngdImageFilledPolygon(img, points, 10, color);\n} \n \xa0\xa0 \n \n', 'tags': '', 'url': '美國國旗程式.html'}, {'title': 'W7', 'text': '', 'tags': '', 'url': 'W7.html'}, {'title': '中國國旗程式', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nvoid draw_chinese_flag(gdImagePtr img);\n \nint main() {\n    int width = 300; // 國旗寬度\n    int height = 200; // 國旗高度\n \n    gdImagePtr im = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(im, 0);\n \n    draw_chinese_flag(im);\n \n    FILE *outputFile = fopen("./../images/proc_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时出错。\\n");\n        return 1;\n    }\n \n    gdImagePngEx(im, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(im);\n \n    return 0;\n}\n \n// 声明 draw_star 函数\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n \nvoid draw_chinese_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, yellow;\n \n    // 國旗顏色\n    red = gdImageColorAllocate(img, 255, 0, 0); // 紅色背景\n    yellow = gdImageColorAllocate(img, 255, 255, 0); // 黃色星星\n \n    // 畫紅色背景\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n \n    // 設置星星的大小和位置\n    int star_size = (int)(0.28 * height);\n    int star_x = (int)(0.165 * width);\n    int star_y = (int)(0.265 * height);\n \n    // 畫大星星\n    draw_star(img, star_x, star_y, star_size, yellow, 11.0);\n \n    // 繪製小星星，位置根據實際國旗比例計算\n    double radius = 0.15 * height;\n    double angle = 360 / 7 * M_PI / 179.0;\n    double rotation = -M_PI / 7.5;\n    int cx = (int)(0.32 * width);\n    int cy = (int)(0.27 * height);\n \n    for (int i = -1; i < 3; i++) {\n        int x = (int)(cx + radius * cos(i * angle + rotation));\n        int y = (int)(cy + radius * sin(i * angle + rotation));\n        draw_star(img, x, y, 19, yellow, M_PI / 5.0);\n    }\n}\n \nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n    gdPoint points[10];\n \n    // 计算星形的五个外点和五个内点\n    double outer_radius = size / 2;\n    double inner_radius = size / 6;\n    double angle = M_PI / 5.0;\n \n    for (int i = 0; i < 10; i++) {\n        double radius = (i % 2 == 0) ? outer_radius : inner_radius;\n        double theta = rotation_angle + i * angle;\n        points[i].x = x + radius * cos(theta);\n        points[i].y = y + radius * sin(theta);\n    }\n \n    // 使用 gdImageFilledPolygon 绘制星形\n    gdImageFilledPolygon(img, points, 10, color);\n} \n \n \n \n \n', 'tags': '', 'url': '中國國旗程式.html'}, {'title': '日本國旗程式', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nvoid draw_japan_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red );\n \nint main() {\n    // width 3: height 2\n    int width = 1200;\n    int height = 2 * width / 3;\n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    draw_japan_flag(img);\n \n    FILE *outputFile = fopen("./../images/japan_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n \nvoid draw_japan_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white ;\n    int center_x =  0.5 * width;\n    int center_y =  0.5 * height;\n    int sun_radius = 145 ;\n \n    // Colors for the flag\n    red = gdImageColorAllocate(img, 242, 0, 0); // Red color\n    white = gdImageColorAllocate(img, 255, 255, 255); // White stripes\n    \n \n    // 繪製白色矩形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n \n \n    // 繪製太陽內部\n    gdImageFilledEllipse(img, center_x, center_y, sun_radius * 3, sun_radius * 3, red);\n} \n \n \n', 'tags': '', 'url': '日本國旗程式.html'}, {'title': '英國國旗程式', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nvoid draw_uk_flag(gdImagePtr img);\nvoid fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color);\n \nint main() {\n    // 设置国旗的宽和高\n    int width = 1200;\n    int height = width / 2;\n \n    // 创建图像\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    // 绘制英国国旗\n    draw_uk_flag(img);\n \n    // 将图像保存到文件\n    FILE *outputFile = fopen("./../images/uk_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时发生错误。\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n \n \n \nvoid draw_uk_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n \n    int red, white, blue;\n    red = gdImageColorAllocate(img, 204, 0, 0);       // 红色\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色\n    blue = gdImageColorAllocate(img, 0, 0, 153);      // 蓝色\n \n    gdImageFilledRectangle(img, 0, 0, width, height, blue);\n \n \n  int x1, y1, x2, y2, x3, y3;\n  {\n    int line_thickness = 100;\n    gdImageSetThickness(img, line_thickness);\n \n    int x1, y1, x2, y2, x3, y3;\n \n    // 绘制白色斜线\n    x1 = 0;\n    y1 = 600;\n    x2 = 1200;\n    y2 = 0;\n    gdImageLine(img, x1, y1, x2, y2, white);\n \n    x1 = 0;\n    y1 = 0;\n    x2 = 1200;\n    y2 = 600;\n    gdImageLine(img, x1, y1, x2, y2, white);\n}\n  {\n    int line_thickness = 33;\n    gdImageSetThickness(img, line_thickness);\n \n     \n    // 绘制红色斜线\n    x1 = 566;\n    y1 = 300;\n    x2 = 1166;\n    y2 = 0;\n    gdImageLine(img, x1, y1, x2, y2, red);\n \n    x1 = 1233;\n    y1 = 600;\n    x2 = 633;\n    y2 = 300;\n    gdImageLine(img, x1, y1, x2, y2, red);\n \n    x1 = 566;\n    y1 = 300;\n    x2 = -33;\n    y2 = 0;\n    gdImageLine(img, x1, y1, x2, y2, red);\n \n    x1 = 600;\n    y1 = 316.5;\n    x2 = 0;\n    y2 = 616.5;\n    gdImageLine(img, x1, y1, x2, y2, red);\n  }\n  {\n  int line_thickness = 33;\n  gdImageSetThickness(img, line_thickness);\n \n  int x1, y1, x2, y2, x3, y3;\n   \n  // 绘制  斜线\n  x1 = 0;\n  y1 = 600;\n  x2 = 1200;\n  y2 = 0;\n  gdImageLine(img, x1, y1, x2, y2, red );\n   \n   \n  x1 = 1200;\n    y1 = 16.5;\n    x2 = 600;\n    y2 = 316.5;\n    gdImageLine(img, x1, y1, x2, y2, white);\n \n \n  x1 = 0;\n    y1 = 583.5;\n    x2 = 600;\n    y2 = 283.5;\n    gdImageLine(img, x1, y1, x2, y2, white);\n     \n   \n  }\n   \n    // 绘制白色十字\n    int cross_width = width / 32;\n    int cross_arm_width = width / 32;\n    int center_x = width / 2;\n    int center_y = height / 2;\n \n    gdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, height, white);\n    gdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, width, center_y - 2.7 * cross_arm_width, white);\n \n    // 绘制红色十字\n    gdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red);\n    gdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, width, center_y - 1.5 * cross_arm_width, red);\n} \n \n \n \n', 'tags': '', 'url': '英國國旗程式.html'}, {'title': '韓國國旗程式', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n#define WIDTH 900\n#define HEIGHT 600\n#define FILENAME "south_korea_flag.png"\n\nint main() {\ngdImagePtr im;\nFILE *pngout;\nint white, black, red, blue;\n\nim = gdImageCreate(WIDTH, HEIGHT);\n\nwhite = gdImageColorAllocate(im, 255, 255, 255);\nblack = gdImageColorAllocate(im, 0, 0, 0);\nred = gdImageColorAllocate(im, 205, 0, 0);\nblue = gdImageColorAllocate(im, 0, 56, 168);\n\n// Background (white)\ngdImageFilledRectangle(im, 0, 0, WIDTH, HEIGHT , white);\n\n// Blue Circle (Yin-Yang Symbol)\ngdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 210, 30, red, gdArc);\n\n// Red Circle (Yin-Yang Symbol)\ngdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 30, 210, blue, gdArc);\n\nint circleX = 385; // 圓心的 X 座標\nint circleY = 262.5; // 圓心的 Y 座標\nint circleRadius = 75;\n\n// 繪製圓形\ngdImageFilledEllipse(im, circleX, circleY, circleRadius * 2, circleRadius * 2, red);\n\nint circleX2 = 515; // 圓心的 X 座標\n\nint circleY2 = 337.5;\n\n// 繪製圓形\ngdImageFilledEllipse(im, circleX2, circleY2, circleRadius * 2, circleRadius * 2, blue);\n\n{\n\n\n// 起點和終點位置\n\nint startX = 340;\n// 線的起點 X 座標\n\nint startY = 90;\n// 線的起點 Y 座標\n\nint endX = 200;\n// 線的終點 X 座標\n\nint endY = 260;\n// 線的終點 Y 座標\n\nint lineWidth = 23; // 線的寬度\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX, startY, endX, endY, black);\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX -35, startY -10, endX -35, endY -10, black);\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX -70, startY -20, endX -70, endY -20, black);\n\nint startX2 = 213;\n// 線的起點 X 座標\n\nint startY2 = 270;\n// 線的起點 Y 座標\n\nint endX2 = 133;\n// 線的終點 X 座標\n\nint endY2 = 210;\n// 線的終點 Y 座標\n\nint lineWidth2 = 25; // 線的寬度\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +3, startY2, endX2 +3, endY2, white);\n\ngdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -17, startY2 +9 , endX2 -17, endY2 +9 , white);\n\ngdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +115, startY2 -145, endX2 +115, endY2 -145, white);\n\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 -155, endX2 +120, endY2 -155, white);\n\ngdImageSetThickness(im, lineWidth +12);\ngdImageLine(im, startX2 +145, startY2 -155, endX2 +145, endY2 -155, white);\n}\n{\n// 起點和終點位置\n\nint startX = 330;\n// 線的起點 X 座標\n\nint startY = 520;\n// 線的起點 Y 座標\n\nint endX = 190;\n// 線的終點 X 座標\n\nint endY = 350;\n// 線的終點 Y 座標\n\nint lineWidth = 23; // 線的寬度\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX, startY, endX, endY, black);\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX -35, startY +10, endX -35, endY +10, black);\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX -70, startY +20, endX -70, endY +20, black);\n\nint startX2 = 213;\n// 線的起點 X 座標\n\nint startY2 = 330;\n// 線的起點 Y 座標\n\nint endX2 = 133;\n// 線的終點 X 座標\n\nint endY2 = 390;\n// 線的終點 Y 座標\n\nint lineWidth2 = 25; // 線的寬度\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth +8);\ngdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white);\n\ngdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white);\n\ngdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white);\n\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white);\n\ngdImageSetThickness(im, lineWidth +14);\ngdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white);\n\ngdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 232, 426, 206, 448, white);\n\n}\n\n{\n// 起點和終點位置\n\nint startX = 564;\n// 線的起點 X 座標\n\nint startY = 520;\n// 線的起點 Y 座標\n\nint endX = 704;\n// 線的終點 X 座標\n\nint endY = 350;\n// 線的終點 Y 座標\n\nint lineWidth = 23; // 線的寬度\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX +70, startY +20, endX +70, endY +20, black);\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX, startY, endX, endY, black);\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX +35, startY +10, endX +35, endY +10, black);\n\ngdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 624, 400, 734, 490, white);\n\nint startX2 = 553;\n// 線的起點 X 座標\n\nint startY2 = 330;\n// 線的起點 Y 座標\n\nint endX2 = 633;\n// 線的終點 X 座標\n\nint endY2 = 390;\n// 線的終點 Y 座標\n\nint lineWidth2 = 25; // 線的寬度\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth +8);\ngdImageLine(im, startX2 +139, startY2, endX2 +139, endY2, white);\n\ngdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 +157, startY2 -9 , endX2 +157, endY2 -9 , white);\n\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +25, startY2 +155, endX2 +25, endY2 +155, white);\n\ngdImageSetThickness(im, lineWidth +30);\ngdImageLine(im, startX2 -3, startY2 +170, endX2 , endY2 +170, white);\n}\n{\n// 起點和終點位置\n\nint startX = 330;\n// 線的起點 X 座標\n\nint startY = 520;\n// 線的起點 Y 座標\n\nint endX = 190;\n// 線的終點 X 座標\n\nint endY = 350;\n// 線的終點 Y 座標\n\nint lineWidth = 23; // 線的寬度\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX, startY, endX, endY, black);\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX -35, startY +10, endX -35, endY +10, black);\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX -70, startY +20, endX -70, endY +20, black);\n\nint startX2 = 213;\n// 線的起點 X 座標\n\nint startY2 = 330;\n// 線的起點 Y 座標\n\nint endX2 = 133;\n// 線的終點 X 座標\n\nint endY2 = 390;\n// 線的終點 Y 座標\n\nint lineWidth2 = 25; // 線的寬度\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth +8);\ngdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white);\n\ngdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white);\n\ngdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white);\n\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white);\n\ngdImageSetThickness(im, lineWidth +14);\ngdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white);\n\ngdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 232, 426, 206, 448, white);\n\n}\n{\n// 起點和終點位置\n\nint startX = 564;\n// 線的起點 X 座標\n\nint startY = 97;\n// 線的起點 Y 座標\n\nint endX = 704;\n// 線的終點 X 座標\n\nint endY = 267;\n// 線的終點 Y 座標\n\nint lineWidth = 23; // 線的寬度\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX +70, startY -20, endX +70, endY -20, black);\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX, startY, endX, endY, black);\n\ngdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 624, 212, 734, 118, white);\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX +35, startY -10, endX +35, endY -10, black);\n\nint startX2 = 553;\n// 線的起點 X 座標\n\nint startY2 = 277;\n// 線的起點 Y 座標\n\nint endX2 = 633;\n// 線的終點 X 座標\n\nint endY2 = 217;\n// 線的終點 Y 座標\n\nint lineWidth2 = 25; // 線的寬度\n\n// 繪製線段\ngdImageSetThickness(im, lineWidth +8);\ngdImageLine(im, startX2 +134, startY2, endX2 +134, endY2, white);\n\ngdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 +157, startY2 +9 , endX2 +157, endY2 +9 , white);\n\ngdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +25, startY2 -155, endX2 +25, endY2 -155, white);\n\ngdImageSetThickness(im, lineWidth +30);\ngdImageLine(im, startX2 -5, startY2 -155, endX2 -5, endY2 -155, white);\n\n}\n\n// Save image\nFILE *outputFile = fopen("./../images/korea_flag.png", "wb");\nif (outputFile == NULL) {\nfprintf(stderr, "Error opening the output file.\\n");\nreturn 1;\n}\ngdImagePngEx(im, outputFile, 9);\nfclose(outputFile);\ngdImageDestroy(im);\nreturn 0;\n} \n \n \n', 'tags': '', 'url': '韓國國旗程式.html'}, {'title': 'C_EX', 'text': '1.\xa0 \n \n #include <stdio.h>\n\nvoid main()\n{\nfloat a = 0.5;\ndouble b = 1.2;\nint c = 3;\n\nb = b + a + c; // 浮点数和整数之间的运算\n\n/* 输出 a、b、c 到屏幕 */\nprintf("a = %3.1f, b = %3.1f, c = %d", a, b, c);\n} \n \n \n 2. \n #include <stdio.h>\n\nint main()\n{\nchar x, y;\nx = \'a\';\ny = (char)97;\n\n/* 输出 x, y, 以及 y 的 ASCII 值 */\nprintf("x = %c, y = %c, y 的 ASCII 值 = %d", x, y, y);\n\nreturn 0;\n} \n \n \n \n 3. \n #include <stdio.h>\n\nint main()\n{\nint a = 64;\nint b = 0x40; // 以十六进制表示\nlong c = 64L;\n\nprintf("%d, %d, %ld", a, b, c);\n\nreturn 0;\n} \n \n \n \n 4. \n #include <stdio.h>\n\nint main()\n{\nint i;\nprintf("输入一个整数：");\nscanf("%d", &i); /* 使用 &（地址运算符）获取变量 i 的地址 */\nprintf("输入的数字是 %d", i);\n\nreturn 0;\n} \n \n \n 5. \n #include <stdio.h>\n\nint main()\n{\nint a, b;\na = 10; b = 3;\n\nprintf("%d \\n", a * b); // 乘法\nprintf("%d \\n", a / b); // 除法\nprintf("%d \\n", a + b); // 加法\nprintf("%d \\n", a - b); // 减法\nprintf("%d \\n", a % b); // 求余\n\nreturn 0;\n} \n \n \n 6. \n #include <stdio.h>\n\nint main()\n{\nint a = 10, b = 5;\n\nprintf("a == b is %d \\n", a == b); // 等于\nprintf("a > b is %d \\n", a > b); // 大于\nprintf("a < b is %d \\n", a < b); // 小于\nprintf("a >= b is %d \\n", a >= b); // 大于等于\nprintf("a <= b is %d \\n", a <= b); // 小于等于\nprintf("a != b is %d \\n", a != b); // 不等于\n\nprintf("\\n");\n\nb = 10;\nprintf("a == b is %d \\n", a == b); // 等于\nprintf("a > b is %d \\n", a > b); // 大于\nprintf("a < b is %d \\n", a < b); // 小于\nprintf("a >= b is %d \\n", a >= b); // 大于等于\nprintf("a <= b is %d \\n", a <= b); // 小于等于\nprintf("a != b is %d \\n", a != b); // 不等于\n\nreturn 0;\n} \n \n \n 7. \n #include <stdio.h>\n\nvoid main()\n{\nint a, b;\na = 15;\nb = 1;\n\nprintf("%d \\n", a | b); /* a OR b（按位或运算） */\nprintf("%d \\n", a & b); /* a AND b（按位与运算） */\nprintf("%d \\n", a ^ b); /* a XOR b（按位异或运算） */\nprintf("%d \\n", a << 1); /* a 位元左移 1 位 */\nprintf("%d \\n", a >> 1); /* a 位元右移一位 */\nprintf("%d \\n", ~a); /* a 的补码运算 */\n\nreturn 0;\n} \n \n \n 8. \n #include <stdio.h>\n\nvoid main()\n{\nint a;\na = 3;\nprintf("%d\\n", !a); /* 打印 a 的逻辑非结果（a 不为 0，则逻辑非为 0） */\n\na = 0;\nprintf("%d\\n", !a); /* 打印 a 的逻辑非结果（a 为 0，则逻辑非为 1） */\n\nreturn 0;\n} \n \n \n 9. \n #include <stdio.h>\n\nvoid main()\n{\nprintf("%d\\n", 1 && 3); /* 打印两个表达式的逻辑与结果（两者都为真，则结果为真） */\nprintf("%d\\n", 0 && 0); /* 打印两个表达式的逻辑与结果（只要有一个为假，则结果为假） */\nprintf("%d\\n", 2 && 2); /* 打印两个表达式的逻辑与结果（两者都为真，则结果为真） */\n\nreturn 0;\n} \n \n \n 10. \n #include <stdio.h>\n\nvoid main()\n{\nchar a;\nprintf("int 类型的大小为 %d 字节\\n", sizeof(int));\nprintf("char 类型变量 a 的大小为 %d 字节\\n", sizeof(a));\n\nreturn 0;\n}\n\n \n \n \n 1. \n #include <stdio.h>\n\n/* 读取和显示一个字符 */\nint main() {\nchar c;\n\nprintf("请输入一个字符： ");\nc = getchar(); /* 读取输入的字符 */\n\nprintf("输入的字符是： ");\nputchar(c); /* 输出字符 */\n\nreturn 0;\n} \n \n \n \n 2. \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 读取两个整数，计算它们的总和并打印结果 */\nint main()\n{\nint this_is_a_number1, this_is_a_number2, total;\n\nprintf("请输入一个整数：\\n ");\nscanf("%d", &this_is_a_number1); /* 读取输入的整数 */\nprintf("你输入了 %d\\n", this_is_a_number1);\n\nprintf("请输入另一个整数：\\n ");\nscanf("%d", &this_is_a_number2); /* 读取输入的整数 */\nprintf("你输入了 %d\\n", this_is_a_number2);\n\ntotal = this_is_a_number1 + this_is_a_number2; /* 计算两个整数的总和 */\nprintf("总和为 %d\\n", total);\n\nreturn 0;\n} \n \n \n \n 3. \n \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 读取两个浮点数，计算它们的总和并打印结果 */\nint main()\n{\nfloat this_is_a_number1, this_is_a_number2, total;\n\nprintf("请输入一个小数：\\n ");\nscanf("%f", &this_is_a_number1); /* 读取输入的浮点数 */\nprintf("你输入了 %f\\n", this_is_a_number1);\n\nprintf("请输入另一个小数：\\n ");\nscanf("%f", &this_is_a_number2); /* 读取输入的浮点数 */\nprintf("你输入了 %f\\n", this_is_a_number2);\n\ntotal = this_is_a_number1 + this_is_a_number2; /* 计算两个浮点数的总和 */\nprintf("总和为 %f\\n", total);\n\nreturn 0;\n}\n \n \n \n 4. \n \n \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 读取两个浮点数，计算它们的乘积并打印结果 */\nint main()\n{\nfloat this_is_a_number1, this_is_a_number2, total;\n\nprintf("请输入一个小数：\\n ");\nscanf("%f", &this_is_a_number1); /* 读取输入的浮点数 */\nprintf("你输入了 %f\\n", this_is_a_number1);\n\nprintf("请输入另一个小数：\\n ");\nscanf("%f", &this_is_a_number2); /* 读取输入的浮点数 */\nprintf("你输入了 %f\\n", this_is_a_number2);\n\ntotal = this_is_a_number1 * this_is_a_number2; /* 计算两个浮点数的乘积 */\nprintf("乘积为 %f\\n", total);\n\nreturn 0;\n} \n \n \n 5. \n \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 除法：计算两个浮点数的商 */\nint main()\n{\nfloat this_is_a_number1, this_is_a_number2, total;\n\nprintf("请输入一个数字：\\n");\nscanf("%f", &this_is_a_number1); /* 读取输入的数字 */\nprintf("你输入了 %f\\n", this_is_a_number1);\n\nprintf("请输入另一个数字：\\n");\nscanf("%f", &this_is_a_number2); /* 读取输入的数字 */\nprintf("你输入了 %f\\n", this_is_a_number2);\n\ntotal = this_is_a_number1 / this_is_a_number2; /* 计算两个数字的商 */\nprintf("商为 %f\\n", total);\n\nreturn 0;\n} \n \n \n 6. \n ##define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 演示 for 循环：计算用户输入的十个浮点数的总和 */\nint main()\n{\nfloat this_is_a_number, total;\nint i;\n\ntotal = 0;\n\n/* for 循环执行 10 次 */\nfor (i = 0; i < 10; i++)\n{\nprintf("请输入一个数字：\\n");\nscanf("%f", &this_is_a_number); /* 读取输入的数字 */\ntotal = total + this_is_a_number;\n}\n\nprintf("总和为：%f\\n", total);\n\nreturn 0;\n}\n\n \n \n \n 7. \n \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 演示嵌套的 for 循环：计算用户输入的二维数组（10行2列）的总和 */\nint main()\n{\nfloat this_is_a_number, total;\nint i, j;\n\ntotal = 0;\n\n/* 外部 for 循环执行 10 次 */\nfor (i = 0; i < 10; i++)\n{\n/* 内部 for 循环执行 2 次 */\nfor (j = 0; j < 2; j++)\n{\nprintf("请输入一个数字：\\n");\nscanf("%f", &this_is_a_number); /* 读取输入的数字 */\ntotal = total + this_is_a_number;\n}\n}\n\nprintf("总和为：%f\\n", total);\n\nreturn 0;\n} \n \n \n 8. \n \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 演示 do-while 循环：计算用户输入的十个浮点数的总和 */\nint main()\n{\nfloat this_is_a_number, total;\nint i;\n\ntotal = 0;\ni = 0;\n\n/* do-while 循环执行，直到 i 的值达到 10 */\ndo\n{\nprintf("请输入一个数字：\\n");\nscanf("%f", &this_is_a_number); /* 读取输入的数字 */\ntotal = total + this_is_a_number;\ni++;\n} while (i < 10);\n\nprintf("总和为：%f\\n", total);\n\nreturn 0;\n} \n \n 9. \n \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* switch语句示例：根据用户输入的整数值执行不同的操作 */\nint main()\n{\nint this_is_a_number;\n\nprintf("请输入一个介于1和5之间的整数：\\n ");\nscanf("%d", &this_is_a_number);\n\nswitch (this_is_a_number)\n{\ncase 1:\nprintf("Case1: 值是：%d", this_is_a_number);\nbreak;\ncase 2:\nprintf("Case2: 值是：%d", this_is_a_number);\nbreak;\ncase 3:\nprintf("Case3: 值是：%d", this_is_a_number);\nbreak;\ncase 4:\nprintf("Case4: 值是：%d", this_is_a_number);\nbreak;\ncase 5:\nprintf("Case5: 值是：%d", this_is_a_number);\nbreak;\ndefault:\nprintf("错误：值是：%d", this_is_a_number); /* 输入的数字不在1和5之间 */\n}\n\nreturn 0;\n} \n \n \n 10. \n \n #include <stdio.h>\n\n/* if语句示例：根据用户输入的整数值执行不同的条件分支 */\nint main()\n{\nint this_is_a_number;\n\nprintf("请输入一个介于1和10之间的整数：\\n ");\nscanf("%d", &this_is_a_number);\n\nif (this_is_a_number < 6)\n{\nprintf("这个数字小于6;\\n ");\n}\n\nprintf("请输入一个介于10和20之间的整数：\\n ");\nscanf("%d", &this_is_a_number);\n\nif (this_is_a_number < 16)\n{\nprintf("这个数字小于16\\n ");\n}\nelse\n{\nprintf("这个数字大于等于16\\n ");\n}\n\nreturn 0;\n} \n \n', 'tags': '', 'url': 'C_EX.html'}, {'title': 'W12', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nint main() {\n    int width = 800;\n    int height = 600;\n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    FILE *outputFile = fopen("hellogd.png", "wb");\n    if (outputFile == NULL) {\n \nfprintf(stderr, "Error opening the output file.\\n");\n \nreturn 1;\n    }\n    \n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int blue = gdImageColorAllocate(img, 0, 0, 255);\n    int black = gdImageColorAllocate(img, 0, 0, 0);\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n    // 長方形塗色\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageFilledRectangle(img, 0, 0, (int)width/4, (int)height/4, blue);\n    // 橢圓形塗色\n    gdImageFilledEllipse(img, (int)width*3/4, (int)height/4, (int)width/4, (int)width/4, red);\n    // 橢圓形畫線\n    gdImageEllipse(img, (int)width*3/4, (int)height*3/4, (int)width/4, (int)width/4, red);\n    // 畫直線\n    gdImageLine(img, (int)width/2, (int)height/2, (int)width/2, (int)height/2 + 100, blue);\n    \n    // 多邊形畫線\n    gdPoint points[4];\n    points[0].x = (int)width/4;\n    points[0].y = (int)height*3/4;\n    points[1].x = points[0].x + 100;\n    points[1].y = points[0].y;\n    points[2].x = points[1].x;\n    points[2].y = points[1].y + 100;\n    points[3].x = points[2].x - 100;\n    points[3].y = points[2].y;\n    gdImagePolygon(img, points, 4, black);\n    \n    // 多邊形塗色\n    gdPoint points2[4];\n    points2[0].x = (int)width/3;\n    points2[0].y = (int)height/2;\n    points2[1].x = points2[0].x + 100;\n    points2[1].y = points2[0].y;\n    points2[2].x = points2[1].x;\n    points2[2].y = points2[1].y + 100;\n    points2[3].x = points2[2].x - 150;\n    points2[3].y = points2[2].y;\n    gdImageFilledPolygon(img, points2, 4, red);\n \n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n} \n \n \n \n', 'tags': '', 'url': 'W12.html'}, {'title': 'W13', 'text': '// 包含標準輸出入程式庫的標頭文件\n#include <stdio.h>\n \n// 主函式\nint main() {\n    // Open a file to write displacement and velocity data\n    FILE *outputFile = fopen("motion_data.txt", "w");\n    if (!outputFile) {\n        fprintf(stderr, "Failed to create data file.\\n");\n        return 1;\n    }\n \n    // Simulate motion for 10 seconds and calculate displacement and velocity, while writing data to the file\n    double x = 0.2;  // Initial displacement\n    double v = 0.0;  // Initial velocity\n    double dt = 0.01; // Time step\n    double t = 0.0;  // Time\n \n    while (t <= 10.0) {\n        double acceleration = (-10.0 * x - 0.5 * v) / 1.0; // Modified system parameters here\n        v += acceleration * dt;\n        x += v * dt;\n \n        fprintf(outputFile, "%lf %lf %lf\\n", t, x, v);\n \n        t += dt;\n    }\n \n    // Close the data file\n    fclose(outputFile);\n \n    // Start a Gnuplot process using popen\n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");\n    if (!gnuplotPipe) {\n        fprintf(stderr, "Failed to start Gnuplot.\\n");\n        return 1;\n    }\n \n    // Use Gnuplot plotting commands, specify font and output as PNG\n    fprintf(gnuplotPipe, "set terminal pngcairo enhanced font \'default,10\' size 800,400\\n");\n    fprintf(gnuplotPipe, "set output \'./../images/motion_plot.png\'\\n");\n    fprintf(gnuplotPipe, "set title \'Displacement and Velocity vs. Time\'\\n");\n    fprintf(gnuplotPipe, "set xlabel \'Time (s)\'\\n");\n    fprintf(gnuplotPipe, "set ylabel \'Displacement (m)\'\\n");\n    fprintf(gnuplotPipe, "plot \'motion_data.txt\' using 1:2 with lines lw 2 title \'Displacement\', \\\n                             \'motion_data.txt\' using 1:3 with lines lw 2 title \'Velocity\'\\n");\n \n    // Close the Gnuplot process\n    fprintf(gnuplotPipe, "exit\\n");\n    pclose(gnuplotPipe);\n \n    return 0;\n} \n \n \n', 'tags': '', 'url': 'W13.html'}, {'title': 'ANSIC', 'text': '#include <stdio.h>\n\nint main(int argc, char** argv) {\n    // 检查C标准版本\n    #if __STDC_VERSION__ >=  201710L\n        printf("我们正在使用 C18 标准!\\n");\n    #elif __STDC_VERSION__ >= 201112L\n        printf("我们正在使用 C11 标准!\\n");\n    #elif __STDC_VERSION__ >= 199901L\n        printf("我们正在使用 C99 标准!\\n");\n    #else\n        printf("我们正在使用 C89/C90 标准!\\n");\n    #endif\n\n    // 表示程序成功执行\n    return 0;\n}\n \n \n \n #include <stdio.h>\n\nint main(int argc, char** argv) {\n// 检查C标准版本\n#if __STDC_VERSION__ >= 201710L\nprintf("我们正在使用 C18 标准!\\n");\n#elif __STDC_VERSION__ >= 201112L\nprintf("我们正在使用 C11 标准!\\n");\n#elif __STDC_VERSION__ >= 199901L\nprintf("我们正在使用 C99 标准!\\n");\n#else\nprintf("我们正在使用 C89/C90 标准!\\n");\n#endif\n\n// 表示程序成功执行\nreturn 0;\n} \n \n \n \xa0 \n #include <stdio.h>\n\nint main()\n{\n// 打印一行井号\nprintf("######\\n");\n\n// 打印一个井号\nprintf("#\\n");\n\n// 打印一个井号\nprintf("#\\n");\n\n// 打印一行井号\nprintf("#####\\n");\n\n// 打印一个井号\nprintf("#\\n");\n\n// 打印一个井号\nprintf("#\\n");\n\n// 打印一个井号\nprintf("#\\n");\n\nreturn 0;\n} \n \n \n \n #include <stdio.h>\n\nint main()\n{\n// 声明并初始化字符变量\nchar char1 = \'X\';\nchar char2 = \'M\';\nchar char3 = \'L\';\n\n// 打印原始和反转顺序的字符\nprintf("%c%c%c的反转是%c%c%c\\n",\nchar1, char2, char3,\nchar3, char2, char1);\n\nreturn 0;\n} \n \n \n \n #include <stdio.h>\n\n/*\n用于存储矩形宽度和高度的变量（单位：英寸）\n*/\nint width;\nint height;\n\nint area; /* 用于存储矩形的面积的变量 */\nint perimeter; /* 用于存储矩形的周长的变量 */\n\nint main() {\n/* 给高度和宽度赋值 */\nheight = 7;\nwidth = 5;\n\n/* 计算矩形的周长 */\nperimeter = 2 * (height + width);\nprintf("矩形的周长 = %d 英寸\\n", perimeter);\n\n/* 计算矩形的面积 */\narea = height * width;\nprintf("矩形的面积 = %d 平方英寸\\n", area);\n\nreturn 0;\n} \n \n \n \n #include <stdio.h>\n\nint main() {\nint radius; /* 用于存储圆的半径的变量 */\nfloat area, perimeter; /* 用于存储圆的面积和周长的变量 */\nradius = 6; /* 为半径赋值 */\n\n/* 计算圆的周长 */\nperimeter = 2 * 3.14 * radius;\nprintf("圆的周长 = %f 英寸\\n", perimeter);\n\n/* 计算圆的面积 */\narea = 3.14 * radius * radius;\nprintf("圆的面积 = %f 平方英寸\\n", area);\n\nreturn 0;\n} \n \n \n \n #include <stdio.h>\n\nint main()\n{\nint a = 125, b = 12345; /* 声明并初始化整数变量 */\nlong ax = 1234567890; /* 声明并初始化长整数变量 */\nshort s = 4043; /* 声明并初始化短整数变量 */\nfloat x = 2.13459; /* 声明并初始化浮点数变量 */\ndouble dx = 1.1415927; /* 声明并初始化双精度浮点数变量 */\nchar c = \'W\'; /* 声明并初始化字符变量 */\nunsigned long ux = 2541567890; /* 声明并初始化无符号长整数变量 */\n\n/* 不同的算术运算和类型转换 */\nprintf("a + c = %d\\n", a + c);\nprintf("x + c = %f\\n", x + c);\nprintf("dx + x = %f\\n", dx + x);\nprintf("((int) dx) + ax = %ld\\n", ((int) dx) + ax);\nprintf("a + x = %f\\n", a + x);\nprintf("s + b = %d\\n", s + b);\nprintf("ax + b = %ld\\n", ax + b);\nprintf("s + c = %hd\\n", s + c);\nprintf("ax + c = %ld\\n", ax + c);\nprintf("ax + ux = %lu\\n", ax + ux);\n\nreturn 0;\n} \n \n \n \n #include <stdio.h>\n\nint main()\n{\nint days, years, weeks;\n\ndays = 1329; // 总天数\n\n// 将天数转换为年、周和天\nyears = days / 365; // 计算年\nweeks = (days % 365) / 7; // 计算周\ndays = days - ((years * 365) + (weeks * 7)); // 计算剩余天数\n\n// 打印结果\nprintf("年: %d\\n", years);\nprintf("周: %d\\n", weeks);\nprintf("天: %d \\n", days);\n\nreturn 0;\n} \n \n \n \n #include <stdio.h>\n\nint main()\n{\nint x, y, sum; // 声明变量，用于存储两个整数及它们的和\n\n// 提示用户输入，并将其存储在 \'x\' 中\nprintf("\\n输入第一个整数：");\nscanf("%d", &x);\n\n// 提示用户输入，并将其存储在 \'y\' 中\nprintf("\\n输入第二个整数：");\nscanf("%d", &y);\n\nsum = x + y; // 计算 \'x\' 和 \'y\' 的和\n\n// 打印和\nprintf("\\n上述两个整数的和 = %d\\n", sum);\n\nreturn 0; // 表示程序成功执行\n} \n \n \xa0 \n #include <stdio.h>\n\nint main()\n{\nint x, y, result; // 声明变量，用于存储两个整数及它们的乘积\n\n// 提示用户输入，并将其存储在 \'x\' 中\nprintf("\\n输入第一个整数：");\nscanf("%d", &x);\n\n// 提示用户输入，并将其存储在 \'y\' 中\nprintf("\\n输入第二个整数：");\nscanf("%d", &y);\n\nresult = x * y; // 计算 \'x\' 和 \'y\' 的乘积\n\n// 打印乘积\nprintf("上述两个整数的乘积 = %d\\n", result);\n\nreturn 0; // 表示程序成功执行\n}\n\n \n \n \n', 'tags': '', 'url': 'ANSIC.html'}, {'title': 'W15', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color);\n \nint main() {\n    // width 3: height 2\n    int width = 1200;\n    // 國旗長寬比為 3:2\n    int height = (int)(width * 2.0 / 3.0);\n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    draw_roc_flag(img);\n \n    FILE *outputFile = fopen("roc_flag_in_gd.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n \nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n \n    // 白日位於青天面積正中央, 因此中心點座標為長寬各 1/4 處\n    int center_x = (int)(width / 4);\n    int center_y = (int)(height / 4);\n \n    int sun_radius = (int)(width / 8);\n    int white_circle_dia = sun_radius;\n    int blue_circle_dia = white_circle_dia + white_circle_dia * 2 / 15;\n \n    red = gdImageColorAllocate(img, 255, 0, 0); // 紅色\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色\n    blue = gdImageColorAllocate(img, 0, 0, 149); // 藍色\n \n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n    gdImageFilledRectangle(img, 0, 0, (int)(width / 2.0), (int)(height / 2.0), blue);\n    draw_white_sun(img, center_x, center_y, sun_radius, white);\n    gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue);\n    gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white);\n \n    // 在青天與滿地紅的圖案中以白色畫線繪製連接菱形的四個關鍵點\n    gdImageSetThickness(img, 10); // 設置線條粗度為10\n    gdImageLine(img, 429, 125, 279, 165, white);\n    gdImageLine(img, 279, 165, 170, 274, white);\n    gdImageLine(img, 170, 274, 170, 274, white);\n    gdImageLine(img, 429, 125, 170, 274, white); // 加入第四條連線\n}\nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color) {\n    // 實現 draw_white_sun 函數的內容\n    // 可以在此處繪製白日的內部圖案\n}\n \n \xa0 \n \n // https://en.wikipedia.org/wiki/Flag_of_the_Republic_of_China \n// 內政部國旗參考資料: https://www.moi.gov.tw/cp.aspx?n=10621 \n// cc roc_flag_in_gd.c -lgd -lm to link with gd and math library \n// https://www.rapidtables.com/web/color/RGB_Color.html \n// 幾何形狀著色與繪圖練習 \n// 以下 gd 繪圖程式嘗試畫出 ROC 國旗, 請根據下列程式內容完成後續的國旗繪圖 \n#include <stdio.h> \n#include <gd.h> \n#include <math.h> \n\nvoid draw_roc_flag(gdImagePtr img); \nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color); \n\nint main() { \n    // width 3: height 2 \n    int width = 1200; \n    // 國旗長寬比為 3:2 \n    int height = (int)(width*2.0 / 3.0); \n\n    gdImagePtr img = gdImageCreateTrueColor(width, height); \n    gdImageAlphaBlending(img, 0); \n\n    draw_roc_flag(img); \n\n    FILE *outputFile = fopen("roc_flag_in_gd.png", "wb"); \n    if (outputFile == NULL) { \n        fprintf(stderr, "Error opening the output file.\\n"); \n        return 1; \n    } \n    gdImagePngEx(img, outputFile, 9); \n    fclose(outputFile); \n    gdImageDestroy(img); \n    return 0; \n} \n\nvoid draw_roc_flag(gdImagePtr img) { \n    int width = gdImageSX(img); \n    int height = gdImageSY(img); \n    int red, white, blue; \n    // 白日位於青天面積正中央, 因此中心點座標為長寬各 1/4 處 \n    int center_x = (int)(width/4); \n    int center_y = (int)(height/4); \n    // gdImageFilledEllipse 需以長寬方向的 diameter 作圖 \n    // 由於中央白日圓形的半徑為青天寬度的 1/8 \n    // 因此中央白日圓形的直徑為青天寬度的 1/4, 也就是國旗寬度的 1/8 \n    // 而且白日十二道光芒的外圍圓形其半徑也是國旗寬度的1/8 \n    int sun_radius = (int)(width/8); \n    // 中央白日圓形的直徑等於十二道光芒外圍圓形的半徑 \n    int white_circle_dia = sun_radius; \n    // 中央藍色圓形半徑為中央白日的 1又 2/15 \n    int blue_circle_dia = white_circle_dia +  white_circle_dia*2/15; \n    // 根據 https://www.moi.gov.tw/cp.aspx?n=10621 訂定國旗三種顏色值 \n    red = gdImageColorAllocate(img, 255, 0, 0); // 紅色 \n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色 \n    blue = gdImageColorAllocate(img, 0, 0, 149); // 藍色 \n    // 根據畫布大小塗上紅色長方形區域 \n    gdImageFilledRectangle(img, 0, 0, width, height, red); \n    // 青天面積為整面國旗的 1/4, 也是採用長方形塗色 \n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue); \n  {int x1 = 429; \n   int y1 = 125; \n   int x2 = 279; \n   int y2 = 165; \n\n   // 畫一條線連接兩個點 \n   gdImageLine(img, x1, y1, x2, y2, white); \n  } \n  {int x1 = 170; \n     int y1 = 274; \n     int x2 = 279; \n     int y2 = 165; \n\n     // 畫一條線連接兩個點 \n     gdImageLine(img, x1, y1, x2, y2, white); \n  } \n  { \n    int x1 = 170; \n     int y1 = 274; \n     int x2 = 429; \n     int y2 = 125; \n\n     // 畫一條線連接兩個點 \n     gdImageLine(img, x1, y1, x2, y2, white); \n  } \n  // 利用一個藍色大圓與白色小圓畫出藍色環狀 \n  gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue); \n  gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white); \n\n\n  // 定義座標結構 \n  typedef struct { \n      double x; \n      double y; \n  } Point; \n\n  // 計算圓與線的交點 \n  void circleLineIntersection(double h, double k, double r, double x1, double y1, double x2, double y2) { \n      // 直線斜率 \n      double m = (y2 - y1) / (x2 - x1); \n\n      // 直線方程式中的常數項 \n      double b = y1 - m * x1; \n\n      // 圓與直線交點的計算 \n      double A = 1 + pow(m, 2); \n      double B = 2 * (m * b - m * k - h); \n      double C = pow(k, 2) - pow(r, 2) + pow(h, 2) - 2 * b * k + pow(b, 2); \n\n      // 判斷交點個數 \n    double discriminant = pow(B, 2) - 4 * A * C; \n    if (discriminant > 0) { \n        double x_intersect1 = (-B + sqrt(discriminant)) / (2 * A); \n        double y_intersect1 = m * x_intersect1 + b; \n        printf("交點: (%.2f, %.2f)\\n", x_intersect1, y_intersect1); \n\n        double x_intersect2 = (-B - sqrt(discriminant)) / (2 * A); \n        double y_intersect2 = m * x_intersect2 + b; \n        printf("交點: (%.2f, %.2f)\\n", x_intersect2, y_intersect2); \n    } else if (discriminant == 0) { \n        double x_intersect = -B / (2 * A); \n        double y_intersect = m * x_intersect + b; \n        printf("交點: (%.2f, %.2f)\\n", x_intersect, y_intersect); \n    } else { \n        printf("No points.\\n"); \n    } \n\n  } \n\n\n      // 圓的參數 \n      double circle_x = (int)(width/4); // 圓心 x 座標 \n      double circle_y = (int)(height/4); // 圓心 y 座標 \n      double radius = white_circle_dia +  white_circle_dia*2/15;   // 圓半徑 \n\n      // 兩點座標 \n\n\n\n  double x3 = 170; \n  double y3 = 274; \n  double x4 = 279; \n  double y4 = 165; \n\n  circleLineIntersection(circle_x, circle_y, radius, x4, y4, x3, y3); \n\n\n  double x5 = 279; \n  double y5 = 165; \n  double x6 = 429; \n  double y6 = 125; \n\n  circleLineIntersection(circle_x, circle_y, radius, x6, y6, x5, y5); \n\n\n\n\n\n\n  } \n \n \n', 'tags': '', 'url': 'W15.html'}, {'title': 'W16', 'text': '#include <gd.h>\n#include <stdio.h>\n#include <math.h>\n \n#define WIDTH 800\n#define HEIGHT 600\n#define SCALE 100\n \nvoid drawResistor(gdImagePtr im, int x1, int y, int width, int height) {\n    int startX = x1 ;\n    int endX = x1 + width ;\n \n    // 第一段直线向前走一段\n    gdImageLine(im, startX, y, startX + width / 4 , y, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上45度\n    gdImageLine(im, startX + width / 4 , y, startX + width / 4 + height / 2 , y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2, y - height / 2 , startX + width / 4 + height / 2 + height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + height, y + height / 2, startX + width / 4 + height / 2 + 2 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 2 * height , y - height / 2, startX + width / 4 + height / 2 + 3 * height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 3 * height, y + height / 2 , startX + width / 4 + height / 2 + 4 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 4 * height, y - height / 2, startX + width / 4 + height / 2 + 5 * height, y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n  // 向上45度\n    gdImageLine(im, startX + width / 4 + height / 2 + 5 * height, y + height / 2, startX + width / 4 + height / 2 + 5 * height + height / 2, y, gdImageColorAllocate(im, 0, 0, 255));\n \n  gdImageLine(im, startX + width / 4 + height / 2 + 5 * height + height / 2, y, startX + width / 4 + height / 2 + 5 * height + height / 2 +5 , y, gdImageColorAllocate(im, 0, 0, 255));\n   \n \n  {\n    int startX = 100;\n  gdImageColorAllocate(im, 0, 0, 255);\n \n \n    // 第一段直线向前走一段\n    gdImageLine(im, startX, y, startX + width / 4 , y, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上45度\n    gdImageLine(im, startX + width / 4 , y, startX + width / 4 + height / 2 , y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2, y - height / 2 , startX + width / 4 + height / 2 + height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + height, y + height / 2, startX + width / 4 + height / 2 + 2 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 2 * height , y - height / 2, startX + width / 4 + height / 2 + 3 * height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上45度\n      gdImageLine(im, startX + width / 4 + height / 2 + 3 * height, y + height / 2, startX + width / 4 + height / 2 + 3 * height + height / 2, y, gdImageColorAllocate(im, 0, 0, 255));\n \n    gdImageLine(im, startX + width / 4 + height / 2 + 3 * height + height / 2, y, startX + width / 4 + height / 2 + 3 * height + height / 2 +5 , y, gdImageColorAllocate(im, 0, 0, 255));\n }\n \n  {\n    int startX = 585;\n  gdImageColorAllocate(im, 0, 0, 255);\n \n \n    // 第一段直线向前走一段\n    gdImageLine(im, startX, y, startX + width / 4 , y, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上45度\n    gdImageLine(im, startX + width / 4 , y, startX + width / 4 + height / 2 , y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n     \n  // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2, y - height / 2 , startX + width / 4 + height / 2 + height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + height, y + height / 2, startX + width / 4 + height / 2 + 2 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n        // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 2 * height , y - height / 2, startX + width / 4 + height / 2 + 3 * height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上45度\n      gdImageLine(im, startX + width / 4 + height / 2 + 3 * height, y + height / 2, startX + width / 4 + height / 2 + 3 * height + height / 2, y, gdImageColorAllocate(im, 0, 0, 255));\n     \n    gdImageLine(im, startX + width / 4 + height / 2 + 3 * height + height / 2, y, startX + width / 4 + height / 2 + 3 * height + height / 2 +5 , y, gdImageColorAllocate(im, 0, 0, 255));\n     \n    gdImageLine(im, 100, y +20, 700, y +20, gdImageColorAllocate(im, 0, 255, 0));\n \n}\n}\n   \nint main() {\n    gdImagePtr im;\n    FILE *outputFile;\n \n    // 创建图像对象\n    im = gdImageCreateTrueColor(WIDTH, HEIGHT);\n    if (im == NULL) {\n        fprintf(stderr, "Error creating GD image.\\n");\n        return 1;\n    }\n \n    outputFile = fopen("1.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n \n    int black, white, red, blue, green;\n \n    black = gdImageColorAllocate(im, 0, 0, 0);\n    white = gdImageColorAllocate(im, 255, 255, 255);\n    red = gdImageColorAllocate(im, 255, 0, 0);\n    blue = gdImageColorAllocate(im, 0, 0, 255);\ngreen = gdImageColorAllocate(im, 0, 255, 0);\n    gdImageFilledRectangle(im, 0, 0, WIDTH - 1, HEIGHT - 1, white);\n \n    // 绘制墙面\n    gdImageLine(im, SCALE, SCALE, SCALE, HEIGHT - SCALE, black);\n    gdImageLine(im, WIDTH - SCALE, SCALE, WIDTH - SCALE, HEIGHT - SCALE, black);\n \n// 绘制彈簧\n    drawResistor(im, WIDTH / 3 + SCALE / 2, HEIGHT / 2, SCALE / 2, SCALE / 4);\n   \n    // 绘制质量（方形）\n    gdImageFilledRectangle(im, WIDTH / 3 - SCALE / 2, HEIGHT / 2 - SCALE / 2, WIDTH / 3 + SCALE / 2, HEIGHT / 2 + SCALE / 2, red);\n    gdImageFilledRectangle(im, WIDTH * 2 / 3 - SCALE / 2, HEIGHT / 2 - SCALE / 2, WIDTH * 2 / 3 + SCALE / 2, HEIGHT / 2 + SCALE / 2, red);\n \n  gdImageFilledRectangle(im, 100, HEIGHT +300, 700, HEIGHT /2 +49 , black);\n \n     \n \n    gdImagePng(im, outputFile);\n    fclose(outputFile);\n    gdImageDestroy(im);\n \n    return 0;\n}\n \n \n \n \n \n #include <stdio.h>\n#include <math.h>\n \n#define TIME_STEP 0.01 // 时间步长\n#define SIMULATION_TIME 10.0 // 模拟时间\n \n// 物体的参数\n#define m1 2.0\n#define m2 3.0\n#define k1 0.5\n#define k2 1.0\n#define k3 1.5\n#define c1 0.25\n#define c2 0.33\n#define c3 0.5\n#define X1_initial 1.0\n#define X2_initial -0.5\n#define V0 0.0\n \n// 计算阻尼力\ndouble dampingForce(double c, double v) {\n    return -c * v;\n}\n \n// 模拟物体运动\nvoid simulateMotion() {\n    double X1 = X1_initial;\n    double X2 = X2_initial;\n    double V1 = V0;\n    double V2 = V0;\n \n    FILE *fp;\n    fp = fopen("motion_data.txt", "w");\n \n    for (double t = 0; t <= SIMULATION_TIME; t += TIME_STEP) {\n        double F1 = -k1 * (X1 - 0) - c1 * (V1 - 0); // 第一个物体受到的合力\n        double F2 = -k2 * (X2 - X1) - c2 * (V2 - V1); // 第二个物体受到的合力\n        double F3 = -k3 * (X2 - 0) - c3 * (V2 - 0); // 第二个物体受到的合力\n \n        double a1 = F1 / m1; // 第一个物体的加速度\n        double a2 = F2 / m2; // 第二个物体的加速度\n \n        // 更新速度和位置\n        V1 += a1 * TIME_STEP;\n        V2 += a2 * TIME_STEP;\n \n        X1 += V1 * TIME_STEP;\n        X2 += V2 * TIME_STEP;\n \n  // 在文件写入时记录 m1 和 m2 的位置和速度数据\n  fprintf(fp, "%lf %lf %lf %lf %lf\\n", t, X1, X2, V1, V2);\n    }\n \n \n    fclose(fp);\n}\n \nint main() {\n    simulateMotion();\n    return 0;\n} \n \n \n \n \n', 'tags': '', 'url': 'W16.html'}, {'title': '教學影片', 'text': '', 'tags': '', 'url': '教學影片.html'}, {'title': '【1.電腦輔助設計室網路設定說明】', 'text': '(1)手動設定，所以關閉自動偵測設定 \n \n (2)手動設定IP位置 \n \n (3)在近端(電腦輔助設計教室) \n \n (4)搜尋控制台 \n \n (5)框框虛擬 打勾實體 \n \n (6)關閉IPV4 \n \n (7)開啟IPV6 \n \n (8)設定DNS \n \n (9)利用隨身碟批次檔案 設定網路環境 \n \n (10)放入對應檔案 \n \n (11)關閉IPV4 開啟IPV6 \n \n', 'tags': '', 'url': '【1.電腦輔助設計室網路設定說明】.html'}, {'title': '【2. Wink 網路設定】', 'text': '(1) \n \n (2) \n \n (3) \n \n (4) \n \n (5) \n \n (6) \n \n (7) \n \n (8) \n \n (9) \n \n', 'tags': '', 'url': '【2. Wink 網路設定】.html'}, {'title': '【4. 安裝與課程相關的 Apps, 網路設定與 ChatGPT 應用】', 'text': '(1)手機安裝Apps:ChatGPT, Github mobile, Replit, Authy, Teams, Onshape \n (2)有技巧詢問ChatGPT \n 手機上的 Github mobile App 可用於 Github 帳號中的 2FA 流程, 幫助 Github 阻絕不當的 robot 濫用. Replit App 利用手機 Run 倉儲網站, 並以手機或平板瀏覽器管理較少量的網站編輯. Authy App 允許使用者利用手機或數位手錶取得 2FA 登入流程所需的 verification code. Teams App 利用手機參與 Microsoft 線上團隊課程. Onshape App 則可讓使用者利用手機或平面檢視或修改協同產品設計流程中的零組件. \n (3)在命令搜尋區輸入 cmd (command 命令提示字元), 後利用 ipconfig /all 指令取得目前的網路設定. \n 2001開始的為外部IP. \n f180為內部. \n 192.168.1為內部IPv4. \n 利用【自動】取的IP位置可減少網路重疊. \n 140.130.1為學校網段. \n \n (4)Q:為甚麼會有兩個冒號? \n \xa0 \xa0 A:因為總共有8個區段，中間有4個區段為0. \n \n (5)Q:出現防火牆把網路關閉? \n \xa0 \xa0 \xa0A:因為電腦中有軟體有問題被防毒軟體誤會要入侵系統才會把網路關閉 \n', 'tags': '', 'url': '【4. 安裝與課程相關的 Apps, 網路設定與 ChatGPT 應用】.html'}, {'title': '【5. 可攜程式環境的設定說明, 如何在可攜環境中編譯執行 C 程式】', 'text': '(1)這門課的可攜環境，雙點擊可以在近端啟動可攜程式環境. \n \n (2)開啟(必須在檢視-顯示項目下勾選"副檔名"與"隱藏的項目"). \n \n (3)會跳出4個命令 \n \n (4) \n \n (5) \n \n (6)用 SciTE 編輯器中的 Tools - Go 功能表執行 ANSI C 程式 \n \n \xa0 (7)10次hello world \n \n (8)清除output \n \n', 'tags': '', 'url': '【5. 可攜程式環境的設定說明, 如何在可攜環境中編譯執行 C 程式】.html'}, {'title': '【9. Github 倉儲設定 Pages 靜態網站】', 'text': '(1)利用主分支建立網頁:Source來源/Branch分支/main主分支 \n \n (2)網頁根目錄 \n \n (3)mdecp2023.github.io/倉儲名稱 \n \n (4) \n \n (5)網址 \n \n', 'tags': '', 'url': '【9. Github 倉儲設定 Pages 靜態網站】.html'}, {'title': '【10. 在 Repllit 中編譯執行 C 程式】', 'text': '(1)靜態 \n \n (2)推送內容及進度 \n \n (3)創建.c \n \n (4)在 Shell 打Clear/cd downloads/cc gnuplot_ex1.c/./a.out \n \n (5)跑出圖片 \n \n (6)C++/複製程式 \n \n (7)貼上圖片 \n \n (8)推上網站 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': '【10. 在 Repllit 中編譯執行 C 程式】.html'}, {'title': 'Brython', 'text': 'https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};